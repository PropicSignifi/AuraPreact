(function(w) {
    /*
     * Check if it is a valid update function.
     * 
     * Please see $Store.
     */
    // isValidUpdateFn :: (State -> Change) -> Boolean
    const isValidUpdateFn = updateFn => {
        return updateFn && _.isFunction(updateFn);
    };

    /*
     * Utility function to fire change event to all the listeners of the store.
     */
    // fireChanges :: (Store, Changes) -> _
    const fireChanges = (store, changes, computedChanges) => {
        _.each(store._listeners, listener => {
            listener(changes, computedChanges);
        });
    };

    /*
     * Utility function to check if the field of the state holds an object value.
     */
    // isObjectField :: (State, State, String) -> String
    const isObjectField = (state, newState, fieldName) =>
        _.isPlainObject(state[fieldName]) || _.isPlainObject(newState[fieldName]);

    /*
     * Create a change object based on the comparison between the two states.
     * 
     * A change object is one with the field names from the new state, and their values
     * are:
     * 
     *   1. true, which means the field has changed
     *   2. false, which means the field is not changed
     *   3. another change object, which contains the change information of the sub object.
     */
    // findChanges :: (State, State) -> Changes
    const findChanges = (state, newState) => {
        return _.mapValues(newState, (value, key) => {
            if(isObjectField(state, newState, key)) {
                if(!value) {
                    return true;
                }
                else {
                    return findChanges(state[key] || {}, value);
                }
            }
            else {
                return !_.isEqual(state[key], value);
            }
        });
    };

    /*
     *  Check if a change object means its related field is changed.
     *  
     *  It the field holds an object value, the field is changed only when at least
     *  one field of the object has changed.
     */
    // isObjectChanged :: a -> Boolean
    const isObjectChanged = target => {
        return _.isEmpty(target) ? true : _.some(target, value => {
            if(_.isBoolean(value)) {
                return value;
            }
            else {
                return isObjectChanged(value);
            }
        });
    };

    /*
     * Convert this object into a normal one.
     * 
     * A normal object should not have any fields with 'undefined' values, so is it
     * true with all its children objects.
     */
    // normalizeObject :: a -> a
    const normalizeObject = target => {
        return _.chain(target)
            .toPairs()
            .reject(pair => _.isUndefined(pair[1]))
            .map(pair => {
                if(_.isPlainObject(pair[1])) {
                    return [pair[0], normalizeObject(pair[1])];
                }
                else {
                    return pair;
                }
            })
            .fromPairs()
            .value();
    };

    /*
     * Run all compute functions on the state and get a computed state.
     * 
     * The keys of the computed state come from the name of the compute functions.
     * The values of the computed state are generated by the outcome of the compute
     * functions.
     */
    // compute :: (ComputeFunctions, State) -> ComputedState
    const compute = (computeFns, state) => {
        return _.mapValues(computeFns, computeFn => {
            const computed = computeFn(state);
            if(_.isFunction(computed)) {
                throw new Error("Incorrect compute function");
            }
            return computed;
        });
    };

    /*
     * Reflect changes in the store.
     * 
     * This wrapper is used for convenient query of whether a field has changed.
     * It handles these cases:
     * 
     * 1. state.a.b is not in the change object, and query "a.b" will return false.
     * 2. state.a.b is in the change object, and query "a.b" will return true.
     * 3. Query "a.b" returns true if at least one field of state.a has changed.
     */
    class $StateChanges {
        constructor(changes) {
            this.changes = changes;
        }

        /*
         * Check if the path of the state has changed.
         */
        contains(path) {
            if(!path) {
                return false;
            }

            let items = path.split(".");
            let target = this.changes;
            let key = null;
            while(!_.isEmpty(items)) {
                key = items.shift();
                if(_.isBoolean(target[key])) {
                    return target[key];
                }
                else if(!target[key]) {
                    return false;
                }

                target = target[key];
            }

            if(target) {
                return isObjectChanged(target);
            }
        }
    }

    /*
     * Store is a centralized place to manage states and state changes.
     * 
     * A state is a core data model used across the whole app. States are immutable
     * plain javascript objects. They are enforced to be immutable, so that when used
     * across the app, there will be no side effect, and the behavior will always be
     * consistent and predictable. The only way to change the state is to use a state
     * change. In this way, a new immutable state will be created based on the old state
     * and the state change.
     * 
     * A state change is a transient plain javascript object representing a change to
     * be applied to the current state. A state change may contain the partial or whole
     * fields of the state. By default, the fields of the state will be changed according
     * to the state change. To delete a field in the state, set its value to be undefined
     * in the state change.
     * 
     * Below is the design pattern for the store.
     * 
     *        Update Request
     *             ⬇ 
     *           Dispatch
     *             ⬇ 
     *           Store
     *             ⬇ 
     *            View
     *             ⬇ 
     *        Update Request
     * 
     * 'Update Request' is a curried Store.Update function that collects parameters and
     * wraps the core logic to update the state.
     * 
     * 'Dispatch' will trigger the dispatch process to handle the Update Request and
     * evolve the state.
     * 
     * Below is the flow of applying the store in lightning components.
     *
     *        Get Store State
     *             ⬇ 
     *     Assemble Update Request
     *             ⬇ 
     *  Dispatch Update Request to Store
     *             ⬇ 
     *      Handle Change Event
     *             ⬇ 
     *      Render UI Change
     * 
     * We move core client logic into stores, and model them as Store.Updates. Refer to
     * $Store#getUpdateFunctions for more information. Store.Update functions are curried,
     * so that you can pack them with values you want to use in the Update function.
     * After you have prepared Store.Update functions, you dispatch it to the Store,
     * requesting for a change. The store accepts this update function and will run it
     * against the current state to generate the change object. Then the store will apply
     * the state change to create a new state. Finally you received the state changed event,
     * and start to query the latest state to continue your view updates. 
     * 
     * And the cycle goes on and on.
     * 
     * Developers of each app can subclass this $Store and implement their own Store.
     */
    class $Store {
        /*
         * Instantiate the Store.
         */
        constructor() {
            this._state = window.$Utils.freezeDeep(_.toPlainObject(this.getInitialState() || {}));
            this._listeners = {};
            // Store.Updates
            this.Updates = _.mapValues(this.getUpdateFunctions() || {},
                updateFn => _.curry(updateFn));
            // Store.Computes
            this.Computes = _.mapValues(this.getComputeFunctions() || {},
                computeFn => _.memoize(computeFn));
            this._computedState = window.$Utils.freezeDeep(compute(this.Computes, this._state));
        }

        /*
         * Get the initial state. 
         * Override this to provide your own initial state.
         */
        getInitialState() {
            // TO BE OVERRIDDEN
            return {};
        }

        /*
         * Get the current state.
         * 
         * The returned state is IMMUTABLE. So if you want to use this state in data binding,
         * please create a clone of it.
         */
        getState() {
            return this._state;
        }

        /*
         *  Get the computed state.
         */
        getComputedState() {
            return this._computedState;
        }

        /*
         * Get the update functions.
         * 
         * Update functions are like this:
         * 
         * {
         *     setParam: (a, b, c, state) => { param: ... },
         * }
         * 
         * Each update function should accept at least one argument, and the last
         * argument will be the state. It should return a state change.
         * 
         * Override this to provide your own update functions.
         */
        getUpdateFunctions() {
            // TO BE OVERRIDDEN
            return {};
        }

        /*
         * Compute functions will get computed values from the state and pass them
         * back to the user.
         * 
         * Compute functions are like this:
         * 
         * {
         *     fullName: state => state.firstName + state.lastName,
         * }
         * 
         * Each compute function accepts only one argument and it is the state. It
         * returns the computed value based on the current state.
         * 
         * Override this to provide your own comput functions.
         */
        getComputeFunctions() {
            // TO BE OVERRIDDEN
            return {};
        }

        /*
         * Register a listener.
         * 
         * Code is like:
         * 
         * TestStore.addListener("TestListener", (changes, computedChanges) => {...})
         * 
         * The listener will accept two arguments. The first is the state change wrapper,
         * and the second is the computed state change wrapper.
         */
        addListener(name, listener) {
            if(name && _.isFunction(listener)) {
                this._listeners[name] = listener;
            }
            else {
                throw new Error("Listener is not valid.");
            }
        }

        /*
         * Unregister a listener with its name.
         */
        removeListener(name) {
            if(name) {
                delete this._listeners[name];
            }
        }

        /*
         * Dispatch a change with the update function.
         * This update function should have already been defined by the concrete store.
         * 
         * Code is like:
         * 
         * TestStore.dispatch(TestStore.Updates.setParam(a, b, c));
         */
        dispatch(updateFn) {
            if(isValidUpdateFn(updateFn)) {
                const oldState = this._state;
                const changeState = updateFn(oldState) || {};
                if(!_.isPlainObject(changeState)) {
                    throw new Error("Incorrect update function");
                }
                const changes = findChanges(oldState, changeState);
                const newState = _.mergeWith({}, oldState, changeState, (objValue, srcValue, key, object) => {
                    if(objValue !== undefined && srcValue === undefined) {
                        delete object[key];
                    }
                    else {
                        // continue with the original merge
                        return undefined;
                    }
                });
                this._state = window.$Utils.freezeDeep(normalizeObject(newState));

                const oldComputedState = this._computedState;
                const newComputedState = compute(this.Computes, this._state);
                const computedChanges = findChanges(oldComputedState, newComputedState);
                this._computedState = window.$Utils.freezeDeep(newComputedState);

                fireChanges(this, new $StateChanges(changes), new $StateChanges(computedChanges));
            }
            else {
                throw new Error("Update function is not valid.");
            }
        }
    }

    window.$Expose.add("$Store", {
        isValidUpdateFn,
        findChanges,
        $StateChanges,
        compute,
    });

    w.$Store = $Store;
})(window);
